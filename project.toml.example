Project.toml format:
[Project]
name = "<name>"
third_party_dir_name = "<name>"
script_dir_name = "<name>"
source_dir_name = "<src>"

[Project.BuildEnvironment]
inherit_from_super = True #default. Turn this off if you do NOT want to inherit
                          #the build environment from the super project. In most
                          #cases, you do.
                          
type = "chroot" #default. Possible values are "host", "chroot", "docker", and "inherited".
                #Automatically changed to "inherited" if this project is being invoked inside
                #a super project.

path = "" #different types have different default values:
          #chroot defaults to "./.build_chroots/project_name
          #"host" throws an error if this value is anything other than "/"
          #"docker" defaults to the same as "chroot", and the docker image, 
          #docker container,and docker volume are always named after the
          #encompassing project.



[Project.dependencies.<dep_name>]
version = {major="", minor="", revision="",  misc=""}
getter = {type = "", getter_opts = {}} #Optional. Defaults to build_environment default getter.

#repo value must be a repository defined as using the "ancillery_repos" property
package_management_options = {apt = {version_mapping=, repo=,}, dnf = {version_mapping=,repo=}}


#Use this to define repos and whatnot that
#are not a part of the normal distribution.
#ancillary_repos are non-standard repos that need to be added
#to the "package_management"-type getters in order to automate
#adding that repo to the build system.

[Project.PackageManagement.APT.ancillary_repos.google_chrome]
url = "https://chrome.googlesource.com"
key_url = "https://chrome.googlesource.com"
architecture="x86_64"
release="sid"

[Project.PackageManagement.DNF.ancillary_repos.google_chrome]
url = "https://somethingredhaty.idunno"
signing_key_url="https://rpmsneedsigningkeystoo.idunno"


[Project.PackageManagement.Portage.ancillary_repos.MyPortageRepo]
url = "https://whereveryouarehostingyourportagerepo.idunno"

[Project.PackageManagement.Portage.ancillary_overlays.MyOverlay]
url = "https://pathtoyouroverlay.idunno"

[Project.PackageManagement.Portage]
set_profile = "some_profile_defined_in_your_repo_or_an_overlay"
package_use.package_name = "USE flags"

[Project.VCS.Git]
http_proxy_auth={username=,password=}



#What about dependencies in the superproject and in different sub-projects that clash with each other?
#The python code maintains a set consisting of known dependencies, indexed by name defined here and by
#    package names, with one index per package management system. If there is a conflict, the build will
#    fail. If the conflict is unavoidable, then one of the offending project must be build in a separate
#    chroot. If one fo the projects involved in the conflict is the base superproject, then the subproject
#    will always be chosen to run in an independent chroot. For this reason, project TOML files must always
#    list ALL required dependencies and must not expect dependencies to be pulled by any other project.
